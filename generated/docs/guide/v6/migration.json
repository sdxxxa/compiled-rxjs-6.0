{
  "id": "guide/v6/migration",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1>RxJS v5.x to v6 Update Guide</h1>\n<p>RxJS v6 has arrived! While this is a major version change (from 5.x to 6.x),\nwe've put in a lot of work to keep the hard breaking changes to a minimum.\nIn most cases, this allows application and library developers to update incrementally\nand use RxJS v6 without any modifications to their code.</p>\n<p>A backward-compatibility layer eases the update process, allowing you to keep your\napps working while you address most code changes at your own pace.\nThe overall process can be carried out in stages:</p>\n<ol>\n<li>\n<p>Update to the latest version of RxJS 5.5 and ensure that you've fixed any issues caused by bug fixes.</p>\n</li>\n<li>\n<p>Install RxJS v6 along with the <a href=\"guide/v6/migration#backwards-compatibility\">backward-compatibility</a> package, <code>rxjs-compat</code>.</p>\n</li>\n<li>\n<p>If your app is affected by the few <a href=\"guide/v6/migration#breaking-changes\">breaking changes</a> not covered by <code>rxjs-compat</code>, update the affected code according to the instructions provided below.</p>\n</li>\n<li>\n<p>Eventually, you will want to <a href=\"guide/v6/migration#drop-compat\">drop the compatibility layer</a> to complete the update to RxJS v6. Doing so will significantly decrease the size of your apps. </p>\n<p>To refactor TypeScript code so that it doesn't depend on rxjs-compat, you can use <code>rxjs-tslint</code>.</p>\n</li>\n</ol>\n<code-example language=\"sh\">\nnpm i -g rxjs-tslint\nrxjs-5-to-6-migrate -p [path/to/tsconfig.json]\n</code-example>\n<ol start=\"5\">\n<li>Before RxJS release v7, you will need to remove and replace all use of <a href=\"guide/v6/migration#deprecations\">deprecated functionality</a>.</li>\n</ol>\n<h2>Backwards compatibility</h2>\n<p>In order to minimize the impact of the upgrade, RxJS v6 releases with a sibling package,  <code>rxjs-compat</code>, which provides a compatibility layer between the v6 and v5 APIs.\nMost developers with existing applications should upgrade by installing both <code>rxjs</code> and <code>rxjs-compat</code> at ^6.0.0:</p>\n<p><code>npm install rxjs@6 rxjs-compat@6 --save</code></p>\n<p>For details about this package, see <a href=\"https://www.npmjs.com/package/rxjs-compat\">https://www.npmjs.com/package/rxjs-compat</a>.</p>\n<p>The compatibility package increases the bundle size of your application, which is why we recommend removing it as soon as your application and dependencies have been updated.\nThis size increase is exacerbated if you are using a version of Webpack before 4.0.0. </p>\n<p>For a full explanation of what you will have to update in order to remove <code>rxjs-compat</code>, see <a href=\"guide/v6/migration#drop-compat\">Dropping the compatibility layer</a>. Note also that fully updating your application to v6 may expose existing type errors that were not previously shown. </p>\n<p><a id=\"breaking-changes\"></a></p>\n<h2>Breaking changes not covered by rxjs-compat</h2>\n<p>If you have installed <code>rxjs-compat</code>, there are only two breaking changes that you might need to address immediately. </p>\n<h3>Synchronous error handling</h3>\n<p>Synchronous error handling (placing a call to the <code>Observable.subscribe()</code> method within a <code>try/catch</code> block) is no longer supported. If it is used, it must be replaced with asynchronous error handling, using the <code>error</code> callback in the <code>Observable.subscribe()</code> method. See <a href=\"guide/v6/migration#ex-1\">examples</a>.</p>\n<h3>TypeScript prototype operators</h3>\n<p>If you are defining your own prototype operators in TypeScript and modifying the <code>Observable</code> namespace, you will need to change your operator code in order to get TypeScript to compile. See <a href=\"guide/v6/migration#ex-2\">examples</a>. This is a relatively rare case, likely to affect only advanced TypeScript developers. </p>\n<p><a id=\"ex-1\"></a>\n<strong>Replacing synchronous error handling</strong>\nThe following example shows code that subscribes to an observable within a <code>try/catch</code> block, in order to handle errors synchronously:</p>\n<code-example language=\"ts\">\ntry {\n  source$.subscribe(nextFn, undefined, completeFn);\n} catch (err) {\n  handleError(err);\n}\n</code-example>\n<p>The following code updates this to handle errors asynchronously by defining an error callback for  <code>Observable.subscribe()</code>:</p>\n<code-example language=\"ts\">\nsource$.subscribe(nextFn, handleError, completeFn);\n</code-example>\n<p>The next example shows a test that relies on synchronous error handling:</p>\n<code-example language=\"ts\">\nit('should emit an error on subscription', () => {\n  expect(source$.subscribe()).toThrow(Error, 'some message');\n});\n</code-example>\n<p>The following code shows how to correct the test to use asynchronous error handling:</p>\n<code-example language=\"ts\">\nit('should emit an error on subscription', (done) => {\n  source$.subscribe({\n    error(err) {\n      expect(err.message).toEqual('some message');\n    }\n  });\n});\n</code-example>\n<p><a id=\"ex-2\"></a>\n<strong>TypeScript user-defined prototype operators</strong></p>\n<p>The following example shows the kind of changes you will need to make in user-defined prototype operators, in order for the TypeScript to compile correctly.</p>\n<p>Here is an example of a user-defined prototype operator:</p>\n<code-example language=\"ts\">\nObservable.prototype.userDefined = function () {\n  return new Observable((subscriber) => {\n    this.subscribe({\n      next(value) { subscriber.next(value); },\n      error(err) { subscriber.error(err); },\n      complete() { subscriber.complete(); },\n   });\n  });\n};\n\nsource$.userDefined().subscribe();\n</code-example>\n<p>To make this code compile correctly in v6, change it as shown here:</p>\n<code-example language=\"ts\">\nconst userDefined = &#x3C;T>() => (source: Observable&#x3C;T>) => new Observable&#x3C;T>((subscriber) => {\n    source.subscribe({\n      next(value) { subscriber.next(value); },\n      error(err) { subscriber.error(err); },\n      complete() { subscriber.complete(); },\n   });\n  });\n});\n\nsource$.pipe(\n  userDefined(),\n)\n.subscribe();\n</code-example>\n<p><a id=\"drop-compat\"></a></p>\n<h2>Dropping the compatibility layer</h2>\n<p>If you use functionality that is removed from v6, but supported by the <code>rxjs-compat</code> package, you must refactor or rewrite code to complete the update to v6. The following areas of functionality depend on the compatibility layer:</p>\n<ul>\n<li>Import paths have changed. </li>\n<li>Operator syntax has changed to use piping instead of chaining. </li>\n<li>Classes that operate on observables have been replaced by functions.</li>\n<li>In functions that have the resultSelector parameter, the parameters have been deprecated in most cases, and removed for two functions. The ones that have been removed must be updated before you can remove the compatibility layer.</li>\n</ul>\n<h3>Import paths</h3>\n<p>If you're a TypeScript developer, it's recommended that you use <code>rxjs-tslint</code> to refactor your import paths.</p>\n<p>For JavaScript developers, the general rule is as follows:</p>\n<ol>\n<li><strong>rxjs:</strong> Creation methods, types, schedulers and utilities</li>\n</ol>\n<code-example language=\"ts\">\nimport { Observable, Subject, asapScheduler, pipe, of, from, interval, merge, fromEvent, SubscriptionLike, PartialObserver } from 'rxjs';\n</code-example>\n<ol start=\"2\">\n<li><strong>rxjs/operators</strong>: All pipeable operators:</li>\n</ol>\n<code-example language=\"ts\">\nimport { map, filter, scan } from 'rxjs/operators';\n</code-example>\n<ol start=\"3\">\n<li><strong>rxjs/webSocket:</strong> The web socket subject implementation</li>\n</ol>\n<code-example language=\"ts\">\nimport { webSocket } from 'rxjs/webSocket';\n</code-example>\n<ol start=\"4\">\n<li><strong>rxjs/ajax</strong>: The Rx ajax implementation</li>\n</ol>\n<code-example language=\"ts\">\nimport { ajax } from 'rxjs/ajax';\n</code-example>\n<ol start=\"5\">\n<li><strong>rxjs/testing</strong>: The testing utilities</li>\n</ol>\n<code-example language=\"ts\">\nimport { TestScheduler } from 'rxjs/testing';\n</code-example>\n<h3>Operator pipe syntax</h3>\n<p>The previous coding style of chaining operators has been replaced by piping the result of one operator to another. Pipeable operators were added in version 5.5. For a full discussion of the reasoning and changes required for pipeable operators, see <a href=\"https://github.com/ReactiveX/rxjs/blob/91088dae1df097be2370c73300ffa11b27fd0100/doc/pipeable-operators.md\">RxJS documentation</a>. </p>\n<p>Before you can remove the compatibility layer, you must refactor your code to use only pipeable operators. For Typescript, the <code>tslint</code> tool automates the process to some extent, by applying the transform to well-typed code.</p>\n<ul>\n<li>See <a href=\"guide/v6/migration#pipe-syntax\">Operator Pipe Syntax</a> for details of how to refactor using <a href=\"https://github.com/reactivex/rxjs-tslint\">rxjs-tslint</a>.</li>\n</ul>\n<h3>Observable classes</h3>\n<p>All observable classes (<a href=\"https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable\">https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable</a>) have been removed from v6, in favor of existing or new operators that perform the same operations as the class methods. For example, <code>ArrayObservable.create(myArray)</code> can be replaced by <code>from(myArray)</code>, or the new operator <code>fromArray()</code>.</p>\n<ul>\n<li>\n<p><code>ConnectableObservable</code> is hidden from direct use in v6 and is accessible only through operators <code>multicast</code>, <code>publish</code>, <code>publishReplay</code>, and <code>publishLast</code>.</p>\n</li>\n<li>\n<p><code>SubscribeOnObservable</code> is hidden from direct use in v6 and is accessible only through operator <code>subscribeOn</code>.</p>\n</li>\n</ul>\n<table>\n  <tbody><tr>\n    <td>v6 creation function</td>\n    <td>v5 class</td>\n  </tr>\n  <tr>\n    <td>from</td>\n    <td>ArrayLikeObservable</td>\n  </tr>\n  <tr>\n    <td>of</td>\n    <td>ArrayObservable</td>\n  </tr>\n  <tr>\n    <td>bindCallback</td>\n    <td>BoundCallbackObservable</td>\n  </tr>\n  <tr>\n    <td>bindNodeCallback</td>\n    <td>BoundNodeCallbackObservable</td>\n  </tr>\n  <tr>\n    <td>defer</td>\n    <td>DeferObservable</td>\n  </tr>\n  <tr>\n    <td>empty or EMPTY (constant)</td>\n    <td>EmptyObservable</td>\n  </tr>\n  <tr>\n    <td>throwError</td>\n    <td>ErrorObservable</td>\n  </tr>\n  <tr>\n    <td>forkJoin</td>\n    <td>ForkJoinObservable</td>\n  </tr>\n  <tr>\n    <td>fromEvent</td>\n    <td>FromEventObservable</td>\n  </tr>\n  <tr>\n    <td>fromEventPattern</td>\n    <td>FromEventPatternObservable</td>\n  </tr>\n  <tr>\n    <td>from</td>\n    <td>FromObservable</td>\n  </tr>\n  <tr>\n    <td>generate</td>\n    <td>GenerateObservable</td>\n  </tr>\n  <tr>\n    <td>iif</td>\n    <td>IfObservable</td>\n  </tr>\n  <tr>\n    <td>interval</td>\n    <td>IntervalObservable</td>\n  </tr>\n  <tr>\n    <td>from</td>\n    <td>IteratorObservable</td>\n  </tr>\n  <tr>\n    <td>NEVER (constant)</td>\n    <td>NeverObservable</td>\n  </tr>\n  <tr>\n    <td>pairs</td>\n    <td>PairsObservable</td>\n  </tr>\n  <tr>\n    <td>from</td>\n    <td>PromiseObservable</td>\n  </tr>\n  <tr>\n    <td>range</td>\n    <td>RangeObservable</td>\n  </tr>\n  <tr>\n    <td>of</td>\n    <td>ScalarObservable</td>\n  </tr>\n  <tr>\n    <td>timer</td>\n    <td>TimerObservable</td>\n  </tr>\n  <tr>\n    <td>using</td>\n    <td>UsingObservable</td>\n  </tr>\n</tbody></table>\n<h3>Result selectors removed or deprecated</h3>\n<p>Result selectors are a feature not many people use (in many cases they weren't documented), but were adding significant bloat to the codebase. If you use them, you will need to replace the discontinued <code>resultSelector</code> parameter with external result-selection code.</p>\n<ul>\n<li>\n<p>The <code>resultSelector</code> parameter for <code>first()</code> and <code>last()</code> are <em>removed</em> in v6. If these are used, the code must be updated to run without the <code>rxjs-compat</code> package.</p>\n</li>\n<li>\n<p>The <code>resultSelector</code> parameter available for many mapping operators has been <em>deprecated</em> for v6 and the implementation re-written to be much smaller. They will continue to work without the compatibility package, but must be replaced before the v7 release. See <a href=\"guide/v6/migration#deprecations\">Deprecations</a>.</p>\n</li>\n</ul>\n<p>See <a href=\"guide/v6/migration#result-selectors\">Result Selector Migration</a> for details of which operators are affected and how to move the result-selection functions out of the operator call.</p>\n<p><a id=\"deprecations\"></a></p>\n<h2>Deprecations</h2>\n<p>Before RxJS releases v7, you will need to remove and replace all use of deprecated functionality. The following areas contain deprecated functionality:</p>\n<ul>\n<li>\n<p><code>Observable.if</code>  and <code>Observable.throw</code>\nThese methods have been replaced by the static <code>iif()</code> and <code>throwError()</code> functions. Use <a href=\"https://github.com/reactivex/rxjs-tslint\">rxjs-tslint</a> to convert method calls with function calls. </p>\n<p>See <a href=\"guide/v6/migration#dep-methods\">Convert deprecated methods</a> for details.</p>\n</li>\n<li>\n<p>\"Creation\" operators\nThe following operators have been moved from <code>rxjs/operators</code> to <code>rxjs</code>, and their usage has changed:</p>\n</li>\n<li>\n<p><code>merge</code></p>\n</li>\n<li>\n<p><code>concat</code></p>\n</li>\n<li>\n<p><code>combineLatest</code></p>\n</li>\n<li>\n<p><code>race</code></p>\n</li>\n<li>\n<p><code>zip</code> </p>\n<p>See <a href=\"guide/v6/migration#dep-methods\">Convert deprecated methods</a> for details.</p>\n</li>\n<li>\n<p>Result selectors</p>\n</li>\n</ul>\n<p>See <a href=\"guide/v6/migration#result-selectors\">Result Selector Migration</a> for details of which operators are affected and how to move the result-selection functions out of the operator call.</p>\n<p><a id=\"pipe-syntax\"></a></p>\n<h3>HowTo: Convert to pipe syntax</h3>\n<p>Before converting dot-chained operators to pipeable operators, make sure you import all operators used from <code>rxjs/operators</code>. For example:</p>\n<code-example>\nimport { map, filter, catchError, mergeMap } from 'rxjs/operators';\n</code-example>\n<p>The following operator names were changed because their dot-chained names are reserved words in JavaScript:</p>\n<ul>\n<li><code>do</code> -> <code>tap</code></li>\n<li><code>catch</code> -> <code>catchError</code></li>\n<li><code>switch</code> -> <code>switchAll</code></li>\n<li><code>finally</code> -> <code>finalize</code></li>\n</ul>\n<p>To convert dot-chained operators to pipeable operators, wrap all operators in the <code>pipe()</code> method from the source observable, remove the dots, and add commas to pass each operation to <code>pipe()</code> as an argument.</p>\n<p>For example, the following code uses chaining:</p>\n<code-example language=\"ts\">\nsource\n .map(x => x + x)\n .mergeMap(n => of(n + 1, n + 2)\n   .filter(x => x % 1 == 0)\n   .scan((acc, x) => acc + x, 0)\n )\n .catch(err => of('error found'))\n .subscribe(printResult);\n</code-example>\n<p>To convert to piping:</p>\n<code-example language=\"ts\">\nsource.pipe(\n map(x => x + x),\n mergeMap(n => of(n + 1, n + 2).pipe(\n   filter(x => x % 1 == 0),\n   scan((acc, x) => acc + x, 0),\n )),\n catchError(err => of('error found')),\n).subscribe(printResult); \n</code-example>\n<p><a id=\"dep-methods\"></a></p>\n<h3>HowTo: Convert deprecated methods</h3>\n<p><strong>Observable.if > iif()</strong></p>\n<code-example language=\"ts\">\nObservable.if(test, a$, b$);\n\n// becomes\n\niif(test, a$, b$);\n</code-example>\n<p><strong>Observable.error > throwError()</strong></p>\n<code-example language=\"ts\">\nObservable.throw(new Error());\n\n// becomes\n\nthrowError(new Error());\n</code-example>\n<p><strong>merge</strong></p>\n<code-example language=\"ts\">\nimport { merge } from 'rxjs/operators';\na$.pipe(merge(b$, c$));\n\n// becomes\n\nimport { merge } from 'rxjs';\nmerge(a$, b$, c$);\n</code-example>\n<p><strong>concat</strong></p>\n<code-example language=\"ts\">\nimport { concat } from 'rxjs/operators';\na$.pipe(concat(b$, c$));\n\n// becomes\n\nimport { concat } from 'rxjs';\nconcat(a$, b$, c$);\n</code-example>\n<p><strong>combineLatest</strong></p>\n<code-example language=\"ts\">\nimport { combineLatest } from 'rxjs/operators';\na$.pipe(combineLatest(b$, c$));\n\n// becomes\n\nimport { combineLatest } from 'rxjs';\ncombineLatest(a$, b$, c$);\n</code-example>\n<p><strong>race</strong></p>\n<code-example language=\"ts\">\nimport { race } from 'rxjs/operators';\na$.pipe(race(b$, c$));\n\n// becomes\n\nimport { race } from 'rxjs';\nrace(a$, b$, c$);\n</code-example>\n<p><strong>zip</strong></p>\n<code-example language=\"ts\">\nimport { zip } from 'rxjs/operators';\na$.pipe(zip(b$, c$));\n\n// becomes\n\nimport { zip } from 'rxjs';\nzip(a$, b$, c$); \n</code-example>\n<p><a id=\"result-selectors\"></a></p>\n<h3>HowTo: Result selector migration</h3>\n<p>In RxJS v5.x, a number of operators have an optional resultSelector argument, in which you can pass a function for handling the result of the operations.  </p>\n<p>If you are using the parameter, you must update your code by moving your result-selection function out of the original operator call, and applying it to the results of the call.</p>\n<ul>\n<li>\n<p>The parameter has been <em>removed </em>from the first() and last() operators in v6, but is supported by the rxjs-compat package. You must update your code in order to drop the compatibility package.</p>\n</li>\n<li>\n<p>The parameter is <em>deprecated </em>in the following operators, and will be removed in v7. You must update your code before moving to the v7.</p>\n<ul>\n<li>mergeMap()</li>\n<li>mergeMapTo()</li>\n<li>concatMap()</li>\n<li>concatMapTo()</li>\n<li>switchMap</li>\n<li>switchMapTo()</li>\n<li>exhaustMap()</li>\n<li>forkJoin()</li>\n<li>zip()</li>\n<li>combineLatest()</li>\n<li>fromEvent()  </li>\n</ul>\n</li>\n</ul>\n<p><strong>first()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n first(predicate, resultSelector, defaultValue)\n) \n</code-example>\n<ul>\n<li>without resultSelector (if you're not using the index in it):</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n first(predicate, defaultValue),\n map(resultSelector)\n) \n</code-example>\n<ul>\n<li>without resultSelector (if you ARE using the index in it)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n map((v, i) => [v, i]),\n first(([v, i]) => predicate(v, i)),\n map(([v, i]) => resultSelector(v, i)),\n)\n</code-example>\n<p><strong>last()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n last(predicate, resultSelector, defaultValue)\n) \n</code-example>\n<ul>\n<li>without resultSelector (if you're not using the index in it):</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n last(predicate, defaultValue),\n map(resultSelector)\n)\n</code-example>\n<ul>\n<li>without resultSelector (if you ARE using the index in it)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n map((v, i) => [v, i]),\n last(([v, i]) => predicate(v, i)),\n map(([v, i]) => resultSelector(v, i)),\n)\n</code-example>\n<p><strong>mergeMap()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)<br>\n<em>NOTE: The concurrency-limit argument is optional, shown here for completeness.</em></li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n mergeMap(fn1, fn2, concurrency)\n)\n</code-example>\n<ul>\n<li>the same functionality without resultSelector, achieved with inner map.</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n mergeMap((a, i) => fn1(a, i).pipe(\n   map((b, ii) => fn2(a, b, i, ii))\n )),\n concurrency\n)\n</code-example>\n<p><strong>mergeMapTo()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n mergeMapTo(a$, resultSelector)\n)\n</code-example>\n<ul>\n<li>without resultSelector</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n mergeMap((x, i) => a$.pipe(\n   map((y, ii) => resultSelector(x, y, i, ii))\n )\n)\n</code-example>\n<p><strong>concatMap()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n concatMap(fn1, fn2)\n)\n</code-example>\n<ul>\n<li>the same functionality without resultSelector, achieved with inner map:</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n concatMap((a, i) => fn1(a, i).pipe(\n   map((b, ii) => fn2(a, b, i, ii))\n )\n)\n</code-example>\n<p><strong>concatMapTo()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n concatMapTo(a$, resultSelector)\n)\n</code-example>\n<ul>\n<li>without resultSelector</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n concatMap((x, i) => a$.pipe(\n   map((y, ii) => resultSelector(x, y, i, ii))\n )\n)\n</code-example>\n<p><strong>switchMap()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n switchMap(fn1, fn2)\n)\n</code-example>\n<ul>\n<li>the same functionality without resultSelector, achieved with inner map</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n switchMap((a, i) => fn1(a, i).pipe(\n   map((b, ii) => fn2(a, b, i, ii))\n )\n)\n</code-example>\n<p><strong>switchMapTo()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n switchMapTo(a$, resultSelector)\n)\n</code-example>\n<ul>\n<li>without resultSelector</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n switchMap((x, i) => a$.pipe(\n   map((y, ii) => resultSelector(x, y, i, ii))\n )\n)\n</code-example>\n<p><strong>exhaustMap()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n exhaustMap(fn1, fn2)\n)\n</code-example>\n<ul>\n<li>the same functionality without resultSelector, achieved with inner map</li>\n</ul>\n<code-example language=\"ts\">\nsource.pipe(\n exhaustMap((a, i) => fn1(a, i).pipe(\n   map((b, ii) => fn2(a, b, i, ii))\n )\n)\n</code-example>\n<p><strong>forkJoin()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nforkJoin(a$, b$, c$, resultSelector)\n// or\nforkJoin([a$, b$, c$], resultSelector)\n</code-example>\n<ul>\n<li>without resultSelector</li>\n</ul>\n<code-example language=\"ts\">\nforkJoin(a$, b$, c$).pipe(\n map(x => resultSelector(...x))\n)\n// or\nforkJoin([a$, b$, c$]).pipe(\n map(x => resultSelector(...x))\n)\n</code-example>\n<p><strong>zip()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nzip(a$, b$, c$, resultSelector)\n// or\nzip([a$, b$, c$], resultSelector)\n</code-example>\n<ul>\n<li>without resultSelector</li>\n</ul>\n<code-example language=\"ts\">\nzip(a$, b$, c$).pipe(\n map(x => resultSelector(...x))\n)\n// or\nzip([a$, b$, c$]).pipe(\n map(x => resultSelector(...x))\n)\n</code-example>\n<p><strong>combineLatest()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\ncombineLatest(a$, b$, c$, resultSelector)\n// or\ncombineLatest([a$, b$, c$], resultSelector)\n</code-example>\n<ul>\n<li>without resultSelector</li>\n</ul>\n<code-example language=\"ts\">\ncombineLatest(a$, b$, c$).pipe(\n map(x => resultSelector(...x))\n)\n// or\ncombineLatest([a$, b$, c$]).pipe(\n map(x => resultSelector(...x))\n)\n</code-example>\n<p><strong>fromEvent()</strong></p>\n<ul>\n<li>with resultSelector (v5.x)</li>\n</ul>\n<code-example language=\"ts\">\nfromEvent(button, 'click', resultSelector)\n</code-example>\n<ul>\n<li>without resultSelector</li>\n</ul>\n<code-example language=\"ts\">\nfromEvent(button, 'click').pipe(\n map(resultSelector)\n)\n</code-example>\n<h3>UMD module name change</h3>\n<p>In RxJS v6.x, UMD module name has been changed from Rx to rxjs so that it's align with other imports module name.</p>\n<code-example language=\"js\">\nconst rx= Rx;\n\nrx.Observable.of(1,2,3).map(x => x + '!!!');\n\n// becomes\n\nconst { of } = rxjs;\nconst { map } = rxjs.operators;\n\nof(1,2,3).pipe(map(x => x + '!!!')); // etc\n</code-example>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/v6/migration#backwards-compatibility\n - guide/v6/migration#breaking-changes\n - guide/v6/migration#dep-methods\n - guide/v6/migration#deprecations\n - guide/v6/migration#drop-compat\n - guide/v6/migration#ex-1\n - guide/v6/migration#ex-2\n - guide/v6/migration#pipe-syntax\n - guide/v6/migration#result-selectors\n - https://github.com/ReactiveX/rxjs/blob/91088dae1df097be2370c73300ffa11b27fd0100/doc/pipeable-operators.md\n - https://github.com/ReactiveX/rxjs/tree/5.5.8/src/observable\n - https://github.com/reactivex/rxjs-tslint\n - https://www.npmjs.com/package/rxjs-compat\n-->"
}