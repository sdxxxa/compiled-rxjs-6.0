{
  "id": "guide/v6/pipeable-operators",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1>Pipeable Operators</h1>\n<p>Starting in version 5.5 we have shipped \"pipeable operators\", which can be accessed in <code>rxjs/operators</code> (notice the pluralized \"operators\"). These are meant to be a better approach for pulling in just the operators you need than the \"patch\" operators found in <code>rxjs-compat</code> package.</p>\n<p><strong>NOTE</strong>: Using <code>rxjs</code> or <code>rxjs/operators</code> without making changes to your build process can result in larger bundles. See <a href=\"guide/v6/pipeable-operators#known-issues\">Known Issues</a> section below.</p>\n<p><strong>Renamed Operators</strong></p>\n<p>Due to having operators available independent of an Observable, operator names cannot conflict with JavaScript keyword restrictions. Therefore the names of the pipeable version of some operators have changed. These operators are:</p>\n<ol>\n<li><code>do</code> -> <code>tap</code></li>\n<li><code>catch</code> -> <code>catchError</code></li>\n<li><code>switch</code> -> <code>switchAll</code></li>\n<li><code>finally</code> -> <code>finalize</code></li>\n</ol>\n<p>The <code>let</code> operator is now part of <code>Observable</code> as <code>pipe</code> and cannot be imported.</p>\n<p><code>source$.let(myOperator) -> source$.pipe(myOperator)</code></p>\n<p>See \"<a href=\"guide/v6/pipeable-operators#build-your-own-operators-easily\">Build Your Own Operators</a>\" below.</p>\n<p>The former <code>toPromise()</code> \"operator\" has been removed\nbecause an operator returns an <code>Observable</code>,\nnot a <code>Promise</code>.\nThere is now an <code>Observable.toPromise()</code>instance method.</p>\n<h2>Why?</h2>\n<p>Problems with the patched operators for dot-chaining are:</p>\n<ol>\n<li>\n<p>Any library that imports a patch operator will augment the <code>Observable.prototype</code> for all consumers of that library, creating blind dependencies. If the library removes their usage, they unknowingly break everyone else. With pipeables, you have to import the operators you need into each file you use them in.</p>\n</li>\n<li>\n<p>Operators patched directly onto the prototype are not <a href=\"https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking\">\"tree-shakeable\"</a> by tools like rollup or webpack. Pipeable operators will be as they are just functions pulled in from modules directly.</p>\n</li>\n<li>\n<p>Unused operators that are being imported in apps cannot be detected reliably by any sort of build tool or lint rule. That means that you might import <code>scan</code>, but stop using it, and it's still being added to your output bundle. With pipeable operators, if you're not using it, a lint rule can pick it up for you.</p>\n</li>\n<li>\n<p>Functional composition is awesome. Building your own custom operators becomes much easier, and now they work and look just like all other operators in rxjs. You don't need to extend Observable or override <code>lift</code> anymore.</p>\n</li>\n</ol>\n<h2>What?</h2>\n<p>What is a pipeable operator? Simply put, a function that can be used with the current <code>let</code> operator. It used to be the origin of the name (\"lettable\"), but that was confusing so we now call them \"pipeable\" because they're intended to be used with the <code>pipe</code> utility. A pipeable operator is basically any function that returns a function with the signature: <code>&#x3C;T, R>(source: Observable&#x3C;T>) => Observable&#x3C;R></code>.</p>\n<p>There is a <code>pipe</code> method built into <code>Observable</code> now at <code>Observable.prototype.pipe</code> that —Åan be used to compose the operators in similar manner to what you're used to with dot-chaining (shown below).</p>\n<p>There is also a <code>pipe</code> utility function that can be imported from <code>import { pipe } from 'rxjs';</code>. The <code>pipe</code> function can be used to build reusable pipeable operators from other pipeable operators. For example:</p>\n<code-example language=\"ts\">\nimport { pipe } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nconst mapTwice = &#x3C;T,R>(fn: (value: T, index: number) => R) => pipe(map(fn), map(fn));\n</code-example>\n<h2>Usage</h2>\n<p>You pull in any operator you need from one spot, under <code>'rxjs/operators'</code> (<strong>plural!</strong>). It's also recommended to pull in the Observable creation methods you need directly as shown below with <code>range</code>:</p>\n<code-example language=\"ts\">\nimport { range } from 'rxjs';\nimport { map, filter, scan } from 'rxjs/operators';\n\nconst source$ = range(0, 10);\n\nsource$.pipe(\n  filter(x => x % 2 === 0),\n  map(x => x + x),\n  scan((acc, x) => acc + x, 0)\n)\n.subscribe(x => console.log(x))\n\n// Logs:\n// 0\n// 4\n// 12\n// 24\n// 40\n</code-example>\n<h2>Build Your Own Operators Easily</h2>\n<p>You, in fact, could <em>always</em> do this with <code>let</code>... but building your own operator is now as simple as writing a function. Notice, that you can compose your custom operator in with other rxjs operators seamlessly.</p>\n<code-example language=\"ts\">\nimport { Observable, interval } from 'rxjs';\nimport { filter, map, take, toArray } from 'rxjs/operators';\n\n/**\n * an operator that takes every Nth value\n */\nconst takeEveryNth = (n: number) => &#x3C;T>(source: Observable&#x3C;T>) =>\n  new Observable&#x3C;T>(observer => {\n    let count = 0;\n    return source.subscribe({\n      next(x) {\n        if (count++ % n === 0) observer.next(x);\n      },\n      error(err) { observer.error(err); },\n      complete() { observer.complete(); }\n    })\n  });\n\n/**\n * You can also use an existing operator like so\n */\nconst takeEveryNthSimple = (n: number) => &#x3C;T>(source: Observable&#x3C;T>) =>\n  source.pipe(filter((value, index) => index % n === 0 ))\n\n/**\n * And since pipeable operators return functions, you can further simplify like so\n */\nconst takeEveryNthSimplest = (n: number) => filter((value, index) => index % n === 0);\n\ninterval(1000).pipe(\n  takeEveryNth(2),\n  map(x => x + x),\n  takeEveryNthSimple(3),\n  map(x => x * x),\n  takeEveryNthSimplest(4),\n  take(3),\n  toArray()\n)\n.subscribe(x => console.log(x));\n// Logs:\n// [0, 2304, 9216]\n</code-example>\n<h2>Known Issues</h2>\n<h3>TypeScript &#x3C; 2.4</h3>\n<p>In TypeScript 2.3 and lower, typings will need to be added to functions passed to operators, as types cannot be inferred prior to TypeScript 2.4. In TypeScript 2.4, types will infer via composition properly.</p>\n<p><strong>TS 2.3 and under</strong></p>\n<code-example language=\"ts\">\nrange(0, 10).pipe(\n  map((n: number) => n + '!'),\n  map((s: string) => 'Hello, ' + s),\n).subscribe(x => console.log(x))\n</code-example>\n<p><strong>TS 2.4 and up</strong></p>\n<code-example language=\"ts\">\nrange(0, 10).pipe(\n  map(n => n + '!'),\n  map(s => 'Hello, ' + s),\n).subscribe(x => console.log(x))\n</code-example>\n<h3>Build and Treeshaking</h3>\n<p>When importing from a manifest (or re-export) file, an application bundle can sometimes grow. Pipeable operators can now be imported from <code>rxjs/operators</code>, but doing so without changing your build process will often result in a larger application bundle. This is because by default <code>rxjs/operators</code> will resolve to the CommonJS output of rxjs.</p>\n<p>In order to use the new pipeable operators and not gain bundle size, you will need to change your Webpack configuration. This will only work with Webpack 3+ as it relies on the new <code>ModuleConcatenationPlugin</code> from Webpack 3.</p>\n<p><strong>path-mapping</strong></p>\n<p>Published along with rxjs 5.5 is builds of rxjs in ECMAScript Module format (imports and exports) with both ES5 and ES2015 language level. You can find these distributions in <code>node_modules/rxjs/_esm5</code> and <code>node_modules/rxjs/_esm2015</code> (\"esm\" stands for ECMAScript Modules and the number \"5\" or \"2015\" is for the ES language level). In your application source code, you should import from <code>rxjs/operators</code>, but in your Webpack configuration file you will need to re-map imports to the ESM5 (or ESM2015) version.</p>\n<p>If you <code>require('rxjs/_esm5/path-mapping')</code>, you will receive a function that returns an object of key-value pairs mapping each input to it's file location on disk. Utilize this mapping as follows:</p>\n<p><strong>webpack.config.js</strong></p>\n<p>Simple configuration:</p>\n<!-- skip-example -->\n<code-example language=\"js\">\nconst rxPaths = require('rxjs/_esm5/path-mapping');\nconst webpack = require('webpack');\nconst path = require('path');\n\nmodule.exports = {\n  entry: 'index.js',\n  output: 'bundle.js',\n  resolve: {\n    // Use the \"alias\" key to resolve to an ESM distribution\n    alias: rxPaths()\n  },\n  plugins: [\n    new webpack.optimize.ModuleConcatenationPlugin()\n  ]\n};\n</code-example>\n<p>More complete configuration (closer to a real-world scenario):</p>\n<!-- skip-example -->\n<code-example language=\"js\">\nconst webpack = require('webpack');\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nconst DashboardPlugin = require('webpack-dashboard/plugin');\nconst nodeEnv = process.env.NODE_ENV || 'development';\nconst isProd = nodeEnv === 'production';\nconst rxPaths = require('rxjs/_esm5/path-mapping');\n\nvar config = {\n    devtool: isProd ? 'hidden-source-map' : 'cheap-eval-source-map',\n    context: path.resolve('./src'),\n    entry: {\n        app: './index.ts',\n        vendor: './vendor.ts'\n    },\n    output: {\n        path: path.resolve('./dist'),\n        filename: '[name].bundle.js',\n        sourceMapFilename: '[name].map',\n        devtoolModuleFilenameTemplate: function (info) {\n            return \"file:///\" + info.absoluteResourcePath;\n        }\n    },\n    module: {\n        rules: [\n            { enforce: 'pre', test: /\\.ts$|\\.tsx$/, exclude: [\"node_modules\"], loader: 'ts-loader' },\n            { test: /\\.html$/, loader: \"html\" },\n            { test: /\\.css$/, loaders: ['style', 'css'] }\n        ]\n    },\n    resolve: {\n        extensions: [\".ts\", \".js\"],\n        modules: [path.resolve('./src'), 'node_modules'],\n        alias: rxPaths()\n    },\n    plugins: [\n        new webpack.DefinePlugin({\n            'process.env': { // eslint-disable-line quote-props\n                NODE_ENV: JSON.stringify(nodeEnv)\n            }\n        }),\n        new webpack.HashedModuleIdsPlugin(),\n        new webpack.optimize.ModuleConcatenationPlugin(),\n        new HtmlWebpackPlugin({\n            title: 'Typescript Webpack Starter',\n            template: '!!ejs-loader!src/index.html'\n        }),\n        new webpack.optimize.CommonsChunkPlugin({\n            name: 'vendor',\n            minChunks: Infinity,\n            filename: 'vendor.bundle.js'\n        }),\n        new webpack.optimize.UglifyJsPlugin({\n            mangle: false,\n            compress: { warnings: false, pure_getters: true, passes: 3, screw_ie8: true, sequences: false },\n            output: { comments: false, beautify: true },\n            sourceMap: false\n        }),\n        new DashboardPlugin(),\n        new webpack.LoaderOptionsPlugin({\n            options: {\n                tslint: {\n                    emitErrors: true,\n                    failOnHint: true\n                }\n            }\n        })\n    ]\n};\n\nmodule.exports = config;\n</code-example>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - guide/v6/pipeable-operators#build-your-own-operators-easily\n - guide/v6/pipeable-operators#known-issues\n - https://developer.mozilla.org/en-US/docs/Glossary/Tree_shaking\n-->"
}