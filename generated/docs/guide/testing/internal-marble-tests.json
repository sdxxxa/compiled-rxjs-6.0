{
  "id": "guide/testing/internal-marble-tests",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1>Writing Marble Tests</h1>\n<div class=\"alert is-critical\">\n  <span>\n    This document refers to the writing marble tests for the <b>RxJS repo internals</b> and is intended for anyone wishing to help maintain the RxJS repo. \n    <b>Users of RxJS</b> should instead view the <a href=\"./guide/testing/marble-testing\">guide for writing marbles tests for applications</a>. \n    The major difference is that the behavior of the TestScheduler differs between manual usage and using the `testScheduler.run(callback)` helper.\n  </span>\n</div>\n<p>\"Marble Tests\" are tests that use a specialized VirtualScheduler called the <code>TestScheduler</code>. They enable us to test\nasynchronous operations in a synchronous and dependable manner. The \"marble notation\" is something that's been adapted\nfrom many teachings and documents by people such as  <a href=\"https://twitter.com/jhusain\">@jhusain</a>, <a href=\"https://twitter.com/headinthebox\">@headinthebox</a>, <a href=\"https://twitter.com/mattpodwysocki\">@mattpodwysocki</a> and <a href=\"https://twitter.com/andrestaltz\">@andrestaltz</a>. In fact,\nAndr√© Staltz first recommended this as a DSL for creating unit tests, and it has since been altered and adopted.</p>\n<h2>See also</h2>\n<ul>\n<li><a href=\"../../code-of-conduct\">Code of Conduct</a></li>\n</ul>\n<h2>Basic methods</h2>\n<p>The unit tests have helper methods that have been added to make creating tests easier.</p>\n<ul>\n<li><code>hot(marbles: string, values?: object, error?: any)</code> - creates a \"hot\" observable (a subject) that will behave\nas though it's already \"running\" when the test begins. An interesting difference is that <code>hot</code> marbles allow a\n<code>^</code> character to signal where the \"zero frame\" is. That is the point at which the subscription to observables\nbeing tested begins.</li>\n<li><code>cold(marbles: string, values?: object, error?: any)</code> - creates a \"cold\" observable whose subscription starts when\nthe test begins.</li>\n<li><code>expectObservable(actual: Observable&#x3C;T>).toBe(marbles: string, values?: object, error?: any)</code> - schedules an assertion\nfor when the TestScheduler flushes. The TestScheduler will automatically flush at the end of your jasmine <code>it</code> block.</li>\n<li><code>expectSubscriptions(actualSubscriptionLogs: SubscriptionLog[]).toBe(subscriptionMarbles: string)</code> - like <code>expectObservable</code> schedules an assertion for when the testScheduler flushes. Both <code>cold()</code> and <code>hot()</code> return an observable with a property <code>subscriptions</code> of type <code>SubscriptionLog[]</code>. Give <code>subscriptions</code> as parameter to <code>expectSubscriptions</code> to assert whether it matches the <code>subscriptionsMarbles</code> marble diagram given in <code>toBe()</code>. Subscription marble diagrams are slightly different than Observable marble diagrams. Read more below.</li>\n</ul>\n<h3>Ergonomic defaults for <code>hot</code> and <code>cold</code></h3>\n<p>In both <code>hot</code> and <code>cold</code> methods, value characters specified in marble diagrams are emitted as strings unless a <code>values</code>\nargument is passed to the method. Therefor:</p>\n<p><code>hot('--a--b')</code> will emit <code>\"a\"</code> and <code>\"b\"</code> whereas</p>\n<p><code>hot('--a--b', { a: 1, b: 2 })</code> will emit <code>1</code> and <code>2</code>.</p>\n<p>Likewise, unspecified errors will just default to the string <code>\"error\"</code>, so:</p>\n<p><code>hot('---#')</code> will emit error <code>\"error\"</code> whereas</p>\n<p><code>hot('---#', null, new SpecialError('test'))</code> will emit <code>new SpecialError('test')</code></p>\n<h2>Marble Syntax</h2>\n<p>Marble syntax is a string which represents events happening over \"time\". The first character of any marble string</p>\n<p>always represents the \"zero frame\". A \"frame\" is somewhat analogous to a virtual millisecond.</p>\n<ul>\n<li><code>\"-\"</code> time: 10 \"frames\" of time passage.</li>\n<li><code>\"|\"</code> complete: The successful completion of an observable. This is the observable producer signaling <code>complete()</code></li>\n<li><code>\"#\"</code> error: An error terminating the observable. This is the observable producer signaling <code>error()</code></li>\n<li><code>\"a\"</code> any character: All other characters represent a value being emitted by the producer signaling <code>next()</code></li>\n<li><code>\"()\"</code> sync groupings: When multiple events need to be in the same frame synchronously, parentheses are used\nto group those events. You can group nexted values, a completion or an error in this manner. The position of the\ninitial <code>(</code> determines the time at which its values are emitted.</li>\n<li><code>\"^\"</code> subscription point: (hot observables only) shows the point at which the tested observables will be subscribed\nto the hot observable. This is the \"zero frame\" for that observable, every frame before the <code>^</code> will be negative.</li>\n</ul>\n<h3>Examples</h3>\n<p><code>'-'</code> or <code>'------'</code>: Equivalent to <code>Observable.never()</code>, or an observable that never emits or completes</p>\n<p><code>|</code>: Equivalent to <code>Observable.empty()</code></p>\n<p><code>#</code>: Equivalent to <code>Observable.throw()</code></p>\n<p><code>'--a--'</code>: An observable that waits 20 \"frames\", emits value <code>a</code> and then never completes.</p>\n<p><code>'--a--b--|'</code>: On frame 20 emit <code>a</code>, on frame 50 emit <code>b</code>, and on frame 80, <code>complete</code></p>\n<p><code>'--a--b--#'</code>: On frame 20 emit <code>a</code>, on frame 50 emit <code>b</code>, and on frame 80, <code>error</code></p>\n<p><code>'-a-^-b--|'</code>: In a hot observable, on frame -20 emit <code>a</code>, then on frame 20 emit <code>b</code>, and on frame 50, <code>complete</code>.</p>\n<p><code>'--(abc)-|'</code>: on frame 20, emit <code>a</code>, <code>b</code>, and <code>c</code>, then on frame 80 <code>complete</code></p>\n<p><code>'-----(a|)'</code>: on frame 50, emit <code>a</code> and <code>complete</code>.</p>\n<h2>Subscription Marble Syntax</h2>\n<p>The subscription marble syntax is slightly different to conventional marble syntax. It represents the <strong>subscription</strong> and an <strong>unsubscription</strong> points happening over time. There should be no other type of event represented in such diagram.</p>\n<ul>\n<li><code>\"-\"</code> time: 10 \"frames\" of the passage.</li>\n<li><code>\"^\"</code> subscription point: shows the point in time at which a subscription happen.</li>\n<li><code>\"!\"</code> unsubscription point: shows the point in time at which a subscription is unsubscribed.</li>\n</ul>\n<p>There should be <strong>at most one</strong> <code>^</code> point in a subscription marble diagram, and <strong>at most one</strong> <code>!</code> point. Other than that, the <code>-</code> character is the only one allowed in a subscription marble diagram.</p>\n<h3>Examples</h3>\n<p><code>'-'</code> or <code>'------'</code>: no subscription ever happened.</p>\n<p><code>'--^--'</code>: a subscription happened after 20 \"frames\" of time passed, and the subscription was not unsubscribed.</p>\n<p><code>'--^--!-'</code>: on frame 20 a subscription happened, and on frame 50 was unsubscribed.</p>\n<h2>Anatomy of a Test</h2>\n<p>A basic test might look as follows:</p>\n<code-example language=\"ts\">\nconst e1 = hot('----a--^--b-------c--|');\nconst e2 = hot(  '---d-^--e---------f-----|');\nconst expected =      '---(be)----c-f-----|';\n\nexpectObservable(e1.merge(e2)).toBe(expected);\n</code-example>\n<ul>\n<li>The <code>^</code> characters of <code>hot</code> observables should <strong>always</strong> be aligned.</li>\n<li>The <strong>first character</strong> of <code>cold</code> observables or expected observables should <strong>always</strong> be aligned\nwith each other, and with the <code>^</code> of hot observables.</li>\n<li>Use default emission values when you can. Specify <code>values</code> when you have to.</li>\n</ul>\n<p>A test example with specified values:</p>\n<code-example language=\"ts\">\nconst values = {\n  a: 1,\n  b: 2,\n  c: 3,\n  d: 4,\n  x: 1 + 3, // a + c\n  y: 2 + 4, // b + d\n}\nconst e1 =    hot('---a---b---|', values);\nconst e2 =    hot('-----c---d---|', values);\nconst expected =  '-----x---y---|';\n\nexpectObservable(e1.zip(e2, function(x, y) { return x + y; }))\n  .toBe(expected, values);\n</code-example>\n<ul>\n<li>Use the same hash to look up all values, this ensures that multiple uses of the same character have the\nsame value.</li>\n<li>Make the result values as obvious as possible as to what they represent, these are <em>tests</em> afterall, we want\nclarity more than efficiency, so <code>x: 1 + 3, // a + c</code> is better than just <code>x: 4</code>. The former conveys <em>why</em> it's 4,\nthe latter does not.</li>\n</ul>\n<p>A test example with subscription assertions:</p>\n<code-example language=\"ts\">\nconst x = cold(        '--a---b---c--|');\nconst xsubs =    '------^-------!';\nconst y = cold(                '---d--e---f---|');\nconst ysubs =    '--------------^-------------!';\nconst e1 = hot(  '------x-------y------|', { x: x, y: y });\nconst expected = '--------a---b----d--e---f---|';\n\nexpectObservable(e1.switch()).toBe(expected);\nexpectSubscriptions(x.subscriptions).toBe(xsubs);\nexpectSubscriptions(y.subscriptions).toBe(ysubs);\n</code-example>\n<ul>\n<li>Align the start of <code>xsubs</code> and <code>ysubs</code> diagrams with <code>expected</code> diagram.</li>\n<li>Notice how the <code>x</code> cold observable is unsubscribed at the same time <code>e1</code> emits <code>y</code>.</li>\n</ul>\n<p>In most tests it will be unnecessary to test subscription and unsubscription points, being either obvious or implied from the <code>expected</code> diagram. In those cases do not write subscription assertions. In test cases that have inner subscriptions or cold observables with multiple subscribers, these subscription assertions can be useful.</p>\n<h2>Generating PNG marble diagrams from tests</h2>\n<p>Typically, each test case in Jasmine is written as <code>it('should do something', function () { /* ... */ })</code>. To mark a test case for PNG diagram generation, you must use the <code>asDiagram(label)</code> function, like this:</p>\n<code-example language=\"ts\">\nit.asDiagram(operatorLabel)('should do something', function () {\n});\n</code-example>\n<p>For instance, with <code>zip</code>, we would write</p>\n<code-example language=\"ts\">\nit.asDiagram('zip')('should zip by concatenating', function () {\n  const e1 =    hot('---a---b---|');\n  const e2 =    hot('-----c---d---|');\n  const expected =  '-----x---y---|';\n  const values = { x: 'ac', y: 'bd' };\n\n  const result = e1.zip(e2, function(x, y) { return String(x) + String(y); });\n\n  expectObservable(result).toBe(expected, values);\n});\n</code-example>\n<p>Then, when running <code>npm run tests2png</code>, this test case will be parsed and a PNG file <code>zip.png</code> (filename determined by <code>${operatorLabel}.png</code>) will be created in the <code>img/</code> folder.</p>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - ../../code-of-conduct\n - ./guide/testing/marble-testing\n - https://twitter.com/andrestaltz\n - https://twitter.com/headinthebox\n - https://twitter.com/jhusain\n - https://twitter.com/mattpodwysocki\n-->"
}