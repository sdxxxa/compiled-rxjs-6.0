{
  "id": "guide/overview",
  "title": "",
  "contents": "\n<div class=\"content\">\n<h1>Introduction</h1>\n<p>RxJS is a library for composing asynchronous and event-based programs by using observable sequences. It provides one core type, the <a href=\"./guide/observable\">Observable</a>, satellite types (Observer, Schedulers, Subjects) and operators inspired by <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.6\">Array#extras</a> (map, filter, reduce, every, etc) to allow handling asynchronous events as collections.</p>\n<p><span class=\"informal\">Think of RxJS as Lodash for events.</span></p>\n<p>ReactiveX combines the <a href=\"https://en.wikipedia.org/wiki/Observer_pattern\">Observer pattern</a> with the <a href=\"https://en.wikipedia.org/wiki/Iterator_pattern\">Iterator pattern</a> and <a href=\"http://martinfowler.com/articles/collection-pipeline/#NestedOperatorExpressions\">functional programming with collections</a> to fill the need for an ideal way of managing sequences of events.</p>\n<p>The essential concepts in RxJS which solve async event management are:</p>\n<ul>\n<li><strong>Observable:</strong> represents the idea of an invokable collection of future values or events.</li>\n<li><strong>Observer:</strong> is a collection of callbacks that knows how to listen to values delivered by the Observable.</li>\n<li><strong>Subscription:</strong> represents the execution of an Observable, is primarily useful for cancelling the execution.</li>\n<li><strong>Operators:</strong> are pure functions that enable a functional programming style of dealing with collections with operations like <code>map</code>, <code>filter</code>, <code>concat</code>, <code>reduce</code>, etc.</li>\n<li><strong>Subject:</strong> is the equivalent to an EventEmitter, and the only way of multicasting a value or event to multiple Observers.</li>\n<li><strong>Schedulers:</strong> are centralized dispatchers to control concurrency, allowing us to coordinate when computation happens on e.g. <code>setTimeout</code> or <code>requestAnimationFrame</code> or others.</li>\n</ul>\n<h2>First examples</h2>\n<p>Normally you register event listeners.</p>\n<code-example language=\"ts\">\ndocument.addEventListener('click', () => console.log('Clicked!'));\n</code-example>\n<p>Using RxJS you create an observable instead.</p>\n<code-example language=\"ts\">\nimport { fromEvent } from 'rxjs';\n\nfromEvent(document, 'click').subscribe(() => console.log('Clicked!'));\n</code-example>\n<h3>Purity</h3>\n<p>What makes RxJS powerful is its ability to produce values using pure functions. That means your code is less prone to errors.</p>\n<p>Normally you would create an impure function, where other\npieces of your code can mess up your state.</p>\n<code-example language=\"ts\">\nlet count = 0;\ndocument.addEventListener('click', () => console.log(`Clicked ${++count} times`));\n</code-example>\n<p>Using RxJS you isolate the state.</p>\n<code-example language=\"ts\">\nimport { fromEvent } from 'rxjs';\nimport { scan } from 'rxjs/operators';\n\nfromEvent(document, 'click')\n  .pipe(scan(count => count + 1, 0))\n  .subscribe(count => console.log(`Clicked ${count} times`));\n</code-example>\n<p>The <strong>scan</strong> operator works just like <strong>reduce</strong> for arrays. It takes a value which is exposed to a callback. The returned value of the callback will then become the next value exposed the next time the callback runs.</p>\n<h3>Flow</h3>\n<p>RxJS has a whole range of operators that helps you control how the events flow through your observables.</p>\n<p>This is how you would allow at most one click per second, with plain JavaScript:</p>\n<code-example language=\"ts\">\nlet count = 0;\nlet rate = 1000;\nlet lastClick = Date.now() - rate;\ndocument.addEventListener('click', () => {\n  if (Date.now() - lastClick >= rate) {\n    console.log(`Clicked ${++count} times`);\n    lastClick = Date.now();\n  }\n});\n</code-example>\n<p>With RxJS:</p>\n<code-example language=\"ts\">\nimport { fromEvent } from 'rxjs';\nimport { throttleTime, scan } from 'rxjs/operators';\n\nfromEvent(document, 'click')\n  .pipe(\n    throttleTime(1000),\n    scan(count => count + 1, 0)\n  )\n  .subscribe(count => console.log(`Clicked ${count} times`));\n</code-example>\n<p>Other flow control operators are <a href=\"../api/operators/filter\"><strong>filter</strong></a>, <a href=\"../api/operators/delay\"><strong>delay</strong></a>, <a href=\"../api/operators/debounceTime\"><strong>debounceTime</strong></a>, <a href=\"../api/operators/take\"><strong>take</strong></a>, <a href=\"../api/operators/takeUntil\"><strong>takeUntil</strong></a>, <a href=\"../api/operators/distinct\"><strong>distinct</strong></a>, <a href=\"../api/operators/distinctUntilChanged\"><strong>distinctUntilChanged</strong></a> etc.</p>\n<h3>Values</h3>\n<p>You can transform the values passed through your observables.</p>\n<p>Here's how you can add the current mouse x position for every click, in plain JavaScript:</p>\n<code-example language=\"ts\">\nlet count = 0;\nconst rate = 1000;\nlet lastClick = Date.now() - rate;\ndocument.addEventListener('click', event => {\n  if (Date.now() - lastClick >= rate) {\n    count += event.clientX;\n    console.log(count);\n    lastClick = Date.now();\n  }\n});\n</code-example>\n<p>With RxJS:</p>\n<code-example language=\"ts\">\nimport { fromEvent } from 'rxjs';\nimport { throttleTime, map, scan } from 'rxjs/operators';\n\nfromEvent(document, 'click')\n  .pipe(\n    throttleTime(1000),\n    map(event => event.clientX),\n    scan((count, clientX) => count + clientX, 0)\n  )\n  .subscribe(count => console.log(count));\n</code-example>\n<p>Other value producing operators are <a href=\"../api/operators/pluck\"><strong>pluck</strong></a>, <a href=\"../api/operators/pairwise\"><strong>pairwise</strong></a>, <a href=\"../api/operators/sample\"><strong>sample</strong></a> etc.</p>\n\n</div>\n<!-- links to this doc:\n-->\n<!-- links from this doc:\n - ../api/operators/debounceTime\n - ../api/operators/delay\n - ../api/operators/distinct\n - ../api/operators/distinctUntilChanged\n - ../api/operators/filter\n - ../api/operators/pairwise\n - ../api/operators/pluck\n - ../api/operators/sample\n - ../api/operators/take\n - ../api/operators/takeUntil\n - ./guide/observable\n - http://martinfowler.com/articles/collection-pipeline/#NestedOperatorExpressions\n - https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/1.6\n - https://en.wikipedia.org/wiki/Iterator_pattern\n - https://en.wikipedia.org/wiki/Observer_pattern\n-->"
}