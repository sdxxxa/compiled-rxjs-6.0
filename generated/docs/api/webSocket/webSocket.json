{
  "id": "api/webSocket/webSocket",
  "title": "webSocket",
  "contents": "\n\n<article>\n  <div class=\"page-actions\">\n    <a href=\"https://github.com/reactivex/rxjs/edit/master/src/internal/observable/dom/webSocket.ts?message=docs(webSocket)%3A%20describe%20your%20change...#L2-L156\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n    <a href=\"https://github.com/reactivex/rxjs/tree/6.4.0/src/internal/observable/dom/webSocket.ts#L2-L156\" aria-label=\"View Source\" title=\"View Source\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">code</i></a>\n  </div>\n  <div class=\"breadcrumb\">\n    <script type=\"application/ld+json\">\n      {\n        \"@context\": \"http://schema.org\",\n        \"@type\": \"BreadcrumbList\",\n        \"itemListElement\": [\n          { \"@type\": \"ListItem\", \"position\": 1, \"item\": { \"@id\": \"https://angular.io//api\", \"name\": \"API\" } },\n          { \"@type\": \"ListItem\", \"position\": 2, \"item\": { \"@id\": \"https://angular.io/api/webSocket\", \"name\": \"rxjs/webSocket\" } },\n          { \"@type\": \"ListItem\", \"position\": 3, \"item\": { \"@id\": \"https://angular.io/api/webSocket/webSocket\", \"name\": \"webSocket\" } }\n        ]\n      }\n    </script>\n      <a href=\"/api\">API</a> / <a href=\"api/webSocket\">rxjs/webSocket</a>\n  </div>\n  <header class=\"api-header\">\n    <h1>webSocket</h1>\n    <label class=\"api-type-label function\">function</label>\n    \n    \n    <label class=\"api-status-label stable\">stable</label>\n    \n  </header>\n  <aio-toc class=\"embedded\"></aio-toc>\n\n  <div class=\"api-body\">\n    \n  <p class=\"short-description\"></p><p>Wrapper around the w3c-compatible WebSocket object provided by the browser.</p>\n<p></p>\n  \n  \n  \n\n  <code-example language=\"ts\" hidecopy=\"true\" class=\"no-box api-heading\"> webSocket&#x3C;T>(urlConfigOrSource: string | WebSocketSubjectConfig&#x3C;T>): WebSocketSubject&#x3C;T></code-example>\n\n\n\n<h4 class=\"no-anchor\">Parameters</h4>\n<table class=\"is-full-width list-table parameters-table function-overload-parameters\">\n  <tbody>\n  \n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>urlConfigOrSource</td>\n      \n      <td class=\"param-description\">\n      <p>        The WebSocket endpoint as an url or an object with\nconfiguration and additional Observers.</p>\n\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n\n<h4 class=\"no-anchor\">Returns</h4>\n<p><code>WebSocketSubject&#x3C;T></code>: Subject which allows to both send and receive messages via WebSocket connection.</p>\n\n\n\n\n\n\n\n\n\n  \n\n<section class=\"description\">\n  <h2>Description</h2>\n  <p><span class=\"informal\"><a href=\"api/index/class/Subject\"><code>Subject</code></a> that communicates with a server via WebSocket</span></p>\n<p><code>webSocket</code> is a factory function that produces a <code>WebSocketSubject</code>,\nwhich can be used to make WebSocket connection with an arbitrary endpoint.\n<code>webSocket</code> accepts as an argument either a string with url of WebSocket endpoint, or an\n<a href=\"api/webSocket/WebSocketSubjectConfig\"><code>WebSocketSubjectConfig</code></a> object for providing additional configuration, as\nwell as Observers for tracking lifecycle of WebSocket connection.</p>\n<p>When <code>WebSocketSubject</code> is subscribed, it attempts to make a socket connection,\nunless there is one made already. This means that many subscribers will always listen\non the same socket, thus saving resources. If however, two instances are made of <code>WebSocketSubject</code>,\neven if these two were provided with the same url, they will attempt to make separate\nconnections. When consumer of a <code>WebSocketSubject</code> unsubscribes, socket connection is closed,\nonly if there are no more subscribers still listening. If after some time a consumer starts\nsubscribing again, connection is reestablished.</p>\n<p>Once connection is made, whenever a new message comes from the server, <code>WebSocketSubject</code> will emit that\nmessage as a value in the stream. By default, a message from the socket is parsed via <code>JSON.parse</code>. If you\nwant to customize how deserialization is handled (if at all), you can provide custom <code>resultSelector</code>\nfunction in <a href=\"api/webSocket/WebSocketSubject\"><code>WebSocketSubject</code></a>. When connection closes, stream will complete, provided it happened without\nany errors. If at any point (starting, maintaining or closing a connection) there is an error,\nstream will also error with whatever WebSocket API has thrown.</p>\n<p>By virtue of being a <a href=\"api/index/class/Subject\"><code>Subject</code></a>, <code>WebSocketSubject</code> allows for receiving and sending messages from the server. In order\nto communicate with a connected endpoint, use <code>next</code>, <code>error</code> and <code>complete</code> methods. <code>next</code> sends a value to the server, so bear in mind\nthat this value will not be serialized beforehand. Because of This, <code>JSON.stringify</code> will have to be called on a value by hand,\nbefore calling <code>next</code> with a result. Note also that if at the moment of nexting value\nthere is no socket connection (for example no one is subscribing), those values will be buffered, and sent when connection\nis finally established. <code>complete</code> method closes socket connection. <code>error</code> does the same,\nas well as notifying the server that something went wrong via status code and string with details of what happened.\nSince status code is required in WebSocket API, <code>WebSocketSubject</code> does not allow, like regular <code>Subject</code>,\narbitrary values being passed to the <code>error</code> method. It needs to be called with an object that has <code>code</code>\nproperty with status code number and optional <code>reason</code> property with string describing details\nof an error.</p>\n<p>Calling <code>next</code> does not affect subscribers of <code>WebSocketSubject</code> - they have no\ninformation that something was sent to the server (unless of course the server\nresponds somehow to a message). On the other hand, since calling <code>complete</code> triggers\nan attempt to close socket connection. If that connection is closed without any errors, stream will\ncomplete, thus notifying all subscribers. And since calling <code>error</code> closes\nsocket connection as well, just with a different status code for the server, if closing itself proceeds\nwithout errors, subscribed Observable will not error, as one might expect, but complete as usual. In both cases\n(calling <code>complete</code> or <code>error</code>), if process of closing socket connection results in some errors, <em>then</em> stream\nwill error.</p>\n<p><strong>Multiplexing</strong></p>\n<p><code>WebSocketSubject</code> has an additional operator, not found in other Subjects. It is called <code>multiplex</code> and it is\nused to simulate opening several socket connections, while in reality maintaining only one.\nFor example, an application has both chat panel and real-time notifications about sport news. Since these are two distinct functions,\nit would make sense to have two separate connections for each. Perhaps there could even be two separate services with WebSocket\nendpoints, running on separate machines with only GUI combining them together. Having a socket connection\nfor each functionality could become too resource expensive. It is a common pattern to have single\nWebSocket endpoint that acts as a gateway for the other services (in this case chat and sport news services).\nEven though there is a single connection in a client app, having the ability to manipulate streams as if it\nwere two separate sockets is desirable. This eliminates manually registering and unregistering in a gateway for\ngiven service and filter out messages of interest. This is exactly what <code>multiplex</code> method is for.</p>\n<p>Method accepts three parameters. First two are functions returning subscription and unsubscription messages\nrespectively. These are messages that will be sent to the server, whenever consumer of resulting Observable\nsubscribes and unsubscribes. Server can use them to verify that some kind of messages should start or stop\nbeing forwarded to the client. In case of the above example application, after getting subscription message with proper identifier,\ngateway server can decide that it should connect to real sport news service and start forwarding messages from it.\nNote that both messages will be sent as returned by the functions, meaning they will have to be serialized manually, just\nas messages pushed via <code>next</code>. Also bear in mind that these messages will be sent on <em>every</em> subscription and\nunsubscription. This is potentially dangerous, because one consumer of an Observable may unsubscribe and the server\nmight stop sending messages, since it got unsubscription message. This needs to be handled\non the server or using <a href=\"api/operators/publish\"><code>publish</code></a> on a Observable returned from 'multiplex'.</p>\n<p>Last argument to <code>multiplex</code> is a <code>messageFilter</code> function which should return a boolean. It is used to filter out messages\nsent by the server to only those that belong to simulated WebSocket stream. For example, server might mark these\nmessages with some kind of string identifier on a message object and <code>messageFilter</code> would return <code>true</code>\nif there is such identifier on an object emitted by the socket. Messages which returns <code>false</code> in <code>messageFilter</code> are simply skipped,\nand are not passed down the stream.</p>\n<p>Return value of <code>multiplex</code> is an Observable with messages incoming from emulated socket connection. Note that this\nis not a <code>WebSocketSubject</code>, so calling <code>next</code> or <code>multiplex</code> again will fail. For pushing values to the\nserver, use root <code>WebSocketSubject</code>.</p>\n<h3>Examples</h3>\n<h4>Listening for messages from the server</h4>\n<code-example language=\"ts\">\nimport { webSocket } from \"rxjs/webSocket\";\nconst subject = webSocket(\"ws://localhost:8081\");\n\nsubject.subscribe(\n   msg => console.log('message received: ' + msg), // Called whenever there is a message from the server.\n   err => console.log(err), // Called if at any point WebSocket API signals some kind of error.\n   () => console.log('complete') // Called when connection is closed (for whatever reason).\n );\n</code-example>\n<h4>Pushing messages to the server</h4>\n<code-example language=\"ts\">\nimport { webSocket } from \"rxjs/webSocket\";\nconst subject = webSocket('ws://localhost:8081');\n\nsubject.subscribe();\n// Note that at least one consumer has to subscribe to the created subject - otherwise \"nexted\" values will be just buffered and not sent,\n// since no connection was established!\n\nsubject.next(JSON.stringify({message: 'some message'}));\n// This will send a message to the server once a connection is made. Remember to serialize sent value first!\n\nsubject.complete(); // Closes the connection.\n\nsubject.error({code: 4000, reason: 'I think our app just broke!'});\n// Also closes the connection, but let's the server know that this closing is caused by some error.\n</code-example>\n<h4>Multiplexing WebSocket</h4>\n<code-example language=\"ts\">\nimport { webSocket } from \"rxjs/webSocket\";\nconst subject = webSocket('ws://localhost:8081');\n\nconst observableA = subject.multiplex(\n  () => JSON.stringify({subscribe: 'A'}), // When server gets this message, it will start sending messages for 'A'...\n  () => JSON.stringify({unsubscribe: 'A'}), // ...and when gets this one, it will stop.\n  message => message.type === 'A' // If the function returns `true` message is passed down the stream. Skipped if the function returns false.\n);\n\nconst observableB = subject.multiplex( // And the same goes for 'B'.\n  () => JSON.stringify({subscribe: 'B'}),\n  () => JSON.stringify({unsubscribe: 'B'}),\n  message => message.type === 'B'\n);\n\nconst subA = observableA.subscribe(messageForA => console.log(messageForA));\n// At this moment WebSocket connection is established. Server gets '{\"subscribe\": \"A\"}' message and starts sending messages for 'A',\n// which we log here.\n\nconst subB = observableB.subscribe(messageForB => console.log(messageForB));\n// Since we already have a connection, we just send '{\"subscribe\": \"B\"}' message to the server. It starts sending messages for 'B',\n// which we log here.\n\nsubB.unsubscribe();\n// Message '{\"unsubscribe\": \"B\"}' is sent to the server, which stops sending 'B' messages.\n\nsubA.unsubscribe();\n// Message '{\"unsubscribe\": \"A\"}' makes the server stop sending messages for 'A'. Since there is no more subscribers to root Subject,\n// socket connection closes.\n</code-example>\n\n</section>\n\n\n\n  \n\n  \n\n\n  </div>\n</article>\n\n<!-- links to this doc:\n - api/webSocket\n - api/webSocket/WebSocketSubjectConfig\n-->\n<!-- links from this doc:\n - /api\n - api/index/class/Subject\n - api/operators/publish\n - api/webSocket\n - api/webSocket/WebSocketSubject\n - api/webSocket/WebSocketSubjectConfig\n - https://github.com/reactivex/rxjs/edit/master/src/internal/observable/dom/webSocket.ts?message=docs(webSocket)%3A%20describe%20your%20change...#L2-L156\n - https://github.com/reactivex/rxjs/tree/6.4.0/src/internal/observable/dom/webSocket.ts#L2-L156\n-->"
}