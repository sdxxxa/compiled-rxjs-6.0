{
  "id": "api/index/function/fromEventPattern",
  "title": "fromEventPattern",
  "contents": "\n\n<article>\n  <div class=\"page-actions\">\n    <a href=\"https://github.com/reactivex/rxjs/edit/master/src/internal/observable/fromEventPattern.ts?message=docs(index)%3A%20describe%20your%20change...#L11-L169\" aria-label=\"Suggest Edits\" title=\"Suggest Edits\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">mode_edit</i></a>\n    <a href=\"https://github.com/reactivex/rxjs/tree/6.4.0/src/internal/observable/fromEventPattern.ts#L11-L169\" aria-label=\"View Source\" title=\"View Source\"><i class=\"material-icons\" aria-hidden=\"true\" role=\"img\">code</i></a>\n  </div>\n  <div class=\"breadcrumb\">\n    <script type=\"application/ld+json\">\n      {\n        \"@context\": \"http://schema.org\",\n        \"@type\": \"BreadcrumbList\",\n        \"itemListElement\": [\n          { \"@type\": \"ListItem\", \"position\": 1, \"item\": { \"@id\": \"https://angular.io//api\", \"name\": \"API\" } },\n          { \"@type\": \"ListItem\", \"position\": 2, \"item\": { \"@id\": \"https://angular.io/api/index\", \"name\": \"rxjs/index\" } },\n          { \"@type\": \"ListItem\", \"position\": 3, \"item\": { \"@id\": \"https://angular.io/api/index/function/fromEventPattern\", \"name\": \"fromEventPattern\" } }\n        ]\n      }\n    </script>\n      <a href=\"/api\">API</a> / <a href=\"api/index\">rxjs/index</a>\n  </div>\n  <header class=\"api-header\">\n    <h1>fromEventPattern</h1>\n    <label class=\"api-type-label function\">function</label>\n    \n    \n    <label class=\"api-status-label stable\">stable</label>\n    \n  </header>\n  <aio-toc class=\"embedded\"></aio-toc>\n\n  <div class=\"api-body\">\n    \n  <p class=\"short-description\"></p><p>Creates an Observable from an arbitrary API for registering event handlers.</p>\n<p></p>\n  \n  \n  \n\n  <code-example language=\"ts\" hidecopy=\"true\" class=\"no-box api-heading\"> fromEventPattern&#x3C;T>(addHandler: (handler: NodeEventHandler) => any, removeHandler?: (handler: NodeEventHandler, signal?: any) => void, resultSelector?: (...args: any[]) => T): Observable&#x3C;T | T[]></code-example>\n\n\n\n<h4 class=\"no-anchor\">Parameters</h4>\n<table class=\"is-full-width list-table parameters-table function-overload-parameters\">\n  <tbody>\n  \n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>addHandler</td>\n      \n      <td class=\"param-description\">\n      <p>        A function that takes\na <code>handler</code> function as argument and attaches it somehow to the actual\nsource of events.</p>\n\n      </td>\n    </tr>\n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>removeHandler</td>\n      \n      <td class=\"param-description\">\n      <p>        Optional. Default is <code>undefined</code>.</p>\n<p>        A function that\ntakes a <code>handler</code> function as an argument and removes it from the event source. If <code>addHandler</code>\nreturns some kind of token, <code>removeHandler</code> function will have it as a second parameter.</p>\n\n      </td>\n    </tr>\n    <tr class=\"function-overload-parameter\">\n      <td class=\"param-name\"><a id=\"\"></a>resultSelector</td>\n      \n      <td class=\"param-description\">\n              <p>Optional. Default is <code>undefined</code>.</p>\n        <p>Type: <code>(...args: any[]) => T</code>.</p>\n        \n      </td>\n    </tr>\n  </tbody>\n</table>\n\n\n<h4 class=\"no-anchor\">Returns</h4>\n<p><code>Observable&#x3C;T | T[]></code>: Observable which, when an event happens, emits first parameter\npassed to registered event handler. Alternatively it emits whatever project function returns\nat that moment.</p>\n\n\n\n\n\n\n\n\n\n  \n\n<section class=\"description\">\n  <h2>Description</h2>\n  <p><span class=\"informal\">When that method for adding event handler was something <a href=\"api/index/function/fromEvent\"><code>fromEvent</code></a>\nwas not prepared for.</span></p>\n<p><img src=\"/assets/images/marble-diagrams/fromEventPattern.png\" width=\"100%\" alt=\"fromEventPattern marble diagram\"></p>\n<p><code>fromEventPattern</code> allows you to convert into an Observable any API that supports registering handler functions\nfor events. It is similar to <a href=\"api/index/function/fromEvent\"><code>fromEvent</code></a>, but far\nmore flexible. In fact, all use cases of <a href=\"api/index/function/fromEvent\"><code>fromEvent</code></a> could be easily handled by\n<code>fromEventPattern</code> (although in slightly more verbose way).</p>\n<p>This operator accepts as a first argument an <code>addHandler</code> function, which will be injected with\nhandler parameter. That handler is actually an event handler function that you now can pass\nto API expecting it. <code>addHandler</code> will be called whenever Observable\nreturned by the operator is subscribed, so registering handler in API will not\nnecessarily happen when <code>fromEventPattern</code> is called.</p>\n<p>After registration, every time an event that we listen to happens,\nObservable returned by <code>fromEventPattern</code> will emit value that event handler\nfunction was called with. Note that if event handler was called with more\nthen one argument, second and following arguments will not appear in the Observable.</p>\n<p>If API you are using allows to unregister event handlers as well, you can pass to <code>fromEventPattern</code>\nanother function - <code>removeHandler</code> - as a second parameter. It will be injected\nwith the same handler function as before, which now you can use to unregister\nit from the API. <code>removeHandler</code> will be called when consumer of resulting Observable\nunsubscribes from it.</p>\n<p>In some APIs unregistering is actually handled differently. Method registering an event handler\nreturns some kind of token, which is later used to identify which function should\nbe unregistered or it itself has method that unregisters event handler.\nIf that is the case with your API, make sure token returned\nby registering method is returned by <code>addHandler</code>. Then it will be passed\nas a second argument to <code>removeHandler</code>, where you will be able to use it.</p>\n<p>If you need access to all event handler parameters (not only the first one),\nor you need to transform them in any way, you can call <code>fromEventPattern</code> with optional\nthird parameter - project function which will accept all arguments passed to\nevent handler when it is called. Whatever is returned from project function will appear on\nresulting stream instead of usual event handlers first argument. This means\nthat default project can be thought of as function that takes its first parameter\nand ignores the rest.</p>\n<h2>Example</h2>\n<h3>Emits clicks happening on the DOM document</h3>\n<code-example language=\"ts\">\nimport { fromEventPattern } from 'rxjs';\n\nfunction addClickHandler(handler) {\n  document.addEventListener('click', handler);\n}\n\nfunction removeClickHandler(handler) {\n  document.removeEventListener('click', handler);\n}\n\nconst clicks = fromEventPattern(\n  addClickHandler,\n  removeClickHandler\n);\nclicks.subscribe(x => console.log(x));\n\n// Whenever you click anywhere in the browser, DOM MouseEvent\n// object will be logged.\n</code-example>\n<h2>Example</h2>\n<h3>Use with API that returns cancellation token</h3>\n<code-example language=\"ts\">\nimport { fromEventPattern } from 'rxjs';\n\nconst token = someAPI.registerEventHandler(function() {});\nsomeAPI.unregisterEventHandler(token); // this APIs cancellation method accepts\n                                       // not handler itself, but special token.\n\nconst someAPIObservable = fromEventPattern(\n  function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...\n  function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.\n);\n</code-example>\n<h2>Example</h2>\n<h3>Use with project function</h3>\n<code-example language=\"ts\">\nimport { fromEventPattern } from 'rxjs';\n\nsomeAPI.registerEventHandler((eventType, eventMessage) => {\n  console.log(eventType, eventMessage); // Logs \"EVENT_TYPE\" \"EVENT_MESSAGE\" to console.\n});\n\nconst someAPIObservable = fromEventPattern(\n  handler => someAPI.registerEventHandler(handler),\n  handler => someAPI.unregisterEventHandler(handler)\n  (eventType, eventMessage) => eventType + \" --- \" + eventMessage // without that function only \"EVENT_TYPE\"\n);                                                                // would be emitted by the Observable\n\nsomeAPIObservable.subscribe(value => console.log(value));\n\n// Logs:\n// \"EVENT_TYPE --- EVENT_MESSAGE\"\n</code-example>\n\n</section>\n\n\n\n  \n\n  \n<section class=\"see-also\">\n  <h2>See Also</h2>\n  <ul>\n  \n    <li><a href=\"api/index/function/fromEvent\"><code>fromEvent</code></a>\n</li>\n    <li><a href=\"api/index/function/bindCallback\"><code>bindCallback</code></a>\n</li>\n    <li><a href=\"api/index/function/bindNodeCallback\"><code>bindNodeCallback</code></a>\n</li>\n  </ul>\n</section>\n\n\n\n  </div>\n</article>\n\n<!-- links to this doc:\n - api/index\n - api/index/function/bindCallback\n - api/index/function/bindNodeCallback\n - api/index/function/from\n - api/index/function/fromEvent\n-->\n<!-- links from this doc:\n - /api\n - api/index\n - api/index/function/bindCallback\n - api/index/function/bindNodeCallback\n - api/index/function/fromEvent\n - https://github.com/reactivex/rxjs/edit/master/src/internal/observable/fromEventPattern.ts?message=docs(index)%3A%20describe%20your%20change...#L11-L169\n - https://github.com/reactivex/rxjs/tree/6.4.0/src/internal/observable/fromEventPattern.ts#L11-L169\n-->"
}